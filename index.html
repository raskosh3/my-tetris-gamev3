<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="telegram:webapp" content="true">
    <title>Тетрис — Классика</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; touch-action:manipulation; }
        body { font-family:Arial; background:#000; color:white; display:flex; flex-direction:column; align-items:center; min-height:100vh; padding:10px; }
        .container { max-width:500px; width:100%; }
        .score { display:flex; justify-content:space-around; background:rgba(255,255,255,0.1); padding:10px; border-radius:15px; margin-bottom:10px; }
        canvas { background:#111; border:4px solid #333; border-radius:15px; image-rendering:pixelated; }
        #tetris { width:100%; height:auto; }
        .next { text-align:center; margin:10px 0; background:rgba(255,255,255,0.1); padding:10px; border-radius:15px; }
        .controls { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-top:15px; }
        .btn { background:rgba(255,255,255,0.2); border:3px solid rgba(255,255,255,0.4); border-radius:15px; height:65px; font-size:28px; display:flex; align-items:center; justify-content:center; }
        .btn:active { background:rgba(255,255,255,0.5); transform:scale(0.95); }
        .drop-btn { background:#ff4444 !important; font-size:18px; }
        .game-over { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:999; justify-content:center; align-items:center; padding:20px; }
        .go-box { background:rgba(255,255,255,0.15); padding:30px; border-radius:20px; text-align:center; max-width:400px; width:100%; backdrop-filter:blur(10px); }
        .name-input { width:100%; padding:15px; font-size:18px; margin:15px 0; border-radius:12px; border:none; text-align:center; }
    </style>
</head>
<body>
<div class="container">
    <div class="score">
        <div><div>Очки</div><b id="score">0</b></div>
        <div><div>Уровень</div><b id="level">1</b></div>
        <div><div>Линии</div><b id="lines">0</b></div>
    </div>
    <canvas id="tetris"></canvas>
    <div class="next">Следующая:<br><canvas id="next" width="100" height="100"></canvas></div>
    <div class="controls">
        <div class="btn" id="left">←</div>
        <div class="btn" id="rotate">↻</div>
        <div class="btn" id="right">→</div>
        <div class="btn" id="down">↓</div>
        <div class="btn drop-btn" colspan="2" id="hard-drop">БЫСТРО ВНИЗ</div>
    </div>
</div>

<div class="game-over" id="game-over">
    <div class="go-box">
        <h2>Игра окончена!</h2>
        <h3>Очки: <span id="final-score">0</span></h3>
        <input type="text" class="name-input" id="name" placeholder="Твоё имя" maxlength="20">
        <div style="margin-top:20px; font-size:14px; opacity:0.8;">Нажми зелёную кнопку ↓</div>
    </div>
</div>

<script>
    const tg = window.Telegram?.WebApp;
    if (tg) { tg.ready(); tg.expand(); }

    const BOT_TOKEN = "7774913864:AAFLyQP6kuVmPcGYKgHOE9YpWJ2G7tGq3JU";
    const USER_ID = tg?.initDataUnsafe?.user?.id || "unknown";

    // === КЛАССИЧЕСКИЕ ФИГУРЫ ===
    const SHAPES = {
        I: { shape: [[1,1,1,1]], color: "#00f0f0" },
        O: { shape: [[1,1],[1,1]], color: "#f0f000" },
        T: { shape: [[0,1,0],[1,1,1]], color: "#a000f0" },
        S: { shape: [[0,1,1],[1,1,0]], color: "#00f000" },
        Z: { shape: [[1,1,0],[0,1,1]], color: "#f00000" },
        J: { shape: [[1,0,0],[1,1,1]], color: "#0000f0" },
        L: { shape: [[0,0,1],[1,1,1]], color: "#f0a000" }
    };

    const PIECES = Object.values(SHAPES);

    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');

    const CELL_SIZE = 30;
    const COLS = 10;
    const ROWS = 20;

    canvas.width = COLS * CELL_SIZE;
    canvas.height = ROWS * CELL_SIZE;

    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let score = 0, lines = 0, level = 1, gameOver = false;

    class Piece {
        constructor() {
            const p = PIECES[Math.floor(Math.random() * PIECES.length)];
            this.shape = p.shape;
            this.color = p.color;
            this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
            this.y = 0;
        }
        rotate() {
            const rotated = this.shape[0].map((_, i) => this.shape.map(row => row[i]).reverse());
            this.shape = rotated;
        }
    }

    let current = new Piece();
    let nextPiece = new Piece();

    function drawCell(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.strokeStyle = "#333";
        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        board.forEach((row, y) => row.forEach((cell, x) => cell && drawCell(x, y, cell)));
        current.shape.forEach((row, dy) => row.forEach((cell, dx) => cell && drawCell(current.x + dx, current.y + dy, current.color)));
    }

    function drawNext() {
        nextCtx.fillStyle = "#000";
        nextCtx.fillRect(0, 0, 100, 100);
        nextPiece.shape.forEach((row, dy) => row.forEach((cell, dx) => cell && drawCell(dx + 1, dy + 1, nextPiece.color, nextCtx, 20)));
    }

    function collide() {
        return current.shape.some((row, dy) =>
            row.some((cell, dx) => cell && (
                current.y + dy >= ROWS ||
                current.x + dx < 0 ||
                current.x + dx >= COLS ||
                board[current.y + dy][current.x + dx]
            ))
        );
    }

    function merge() {
        current.shape.forEach((row, dy) =>
            row.forEach((cell, dx) => {
                if (cell && current.y + dy >= 0) {
                    board[current.y + dy][current.x + dx] = current.color;
                }
            })
        );
    }

    function clearLines() {
        let cleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (board[y].every(cell => cell)) {
                board.splice(y, 1);
                board.unshift(Array(COLS).fill(0));
                cleared++;
                y++;
            }
        }
        if (cleared) {
            score += [100, 300, 500, 800][cleared - 1] * level;
            lines += cleared;
            if (lines >= level * 10) level++;
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }
    }

    function drop() {
        current.y++;
        if (collide()) {
            current.y--;
            merge();
            clearLines();
            current = nextPiece;
            nextPiece = new Piece();
            drawNext();
            if (collide()) {
                gameOver = true;
                showGameOver();
            }
        }
        draw();
    }

    function hardDrop() {
        while (!collide()) current.y++;
        current.y--;
        drop();
    }

    // Управление
    document.getElementById('left').ontouchstart = () => { current.x--; if (collide()) current.x++; draw(); };
    document.getElementById('right').ontouchstart = () => { current.x++; if (collide()) current.x--; draw(); };
    document.getElementById('down').ontouchstart = drop;
    document.getElementById('rotate').ontouchstart = () => { current.rotate(); if (collide()) current.rotate(), current.rotate(), current.rotate(); draw(); };
    document.getElementById('hard-drop').ontouchstart = hardDrop;

    function showGameOver() {
        document.getElementById('final-score').textContent = score;
        document.getElementById('game-over').style.display = 'flex';

        if (tg?.initDataUnsafe?.user) {
            const u = tg.initDataUnsafe.user;
            document.getElementById('name').value = u.username ? `@${u.username}` : u.first_name;
        }

        const send = async () => {
            const name = (document.getElementById('name').value || "Аноним").trim().slice(0,20);
            const text = `НОВЫЙ РЕКОРД ТЕТРИС\n\nИгрок: ${name}\nОчки: ${score}\nID: ${USER_ID}`;

            await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ chat_id: USER_ID, text, parse_mode: "Markdown" })
            });

            tg?.MainButton?.setText("Отправлено!");
            setTimeout(() => tg?.close?.(), 1500);
        };

        if (tg) {
            tg.MainButton.text = `Отправить ${score} очков`;
            tg.MainButton.color = "#40b345";
            tg.MainButton.show();
            tg.MainButton.offClick?.();
            tg.MainButton.onClick(send);
        }
    }

    draw(); drawNext();
    setInterval(drop, 800 / level);
</script>
</body>
</html>
